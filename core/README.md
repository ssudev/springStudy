## 스프링 핵심 원리 - 기본편 
- https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8/dashboard

### 객체 지향 설계의 5가지 원칙
- SRP 단일 책임 원칙 : 한 클래스는 하나의 책임만 가진다.
- DIP 의존관계 역전 원칙 : 추상화에 의존하고, 구체화에 의존하면 안된다.
- OCP : 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.

### Ioc, DI 그리고 컨테이너
- AppConfig 처럼 객체를 생성하고 관리하면서 의존관계를 연결해 주는 것을 IoC 컨테이너 또는 **DI 컨테이너** 라고 한다.
- 의존관계 주입에 초점을 맞추어 최근에는 주로 DI 컨테이너라 한다.

### 프레임워크 VS 라이브러리
- 프레임워크가 내가 작성한 코드를 제어하고, 대신 실행하면 그것은 프레임워크가 맞다(JUnit)
- 반면에 내가 작성한 코드가 직접 제어의 흐름을 담당한다면 그것은 프레임워크가 아니고 라이브러리다.

### 스프링 컨테이너
- 'ApplicationContext'를 스프링 컨테이너라 한다.
- 'ApplicationContext'는 인터페이스이다.
- 스프링 컨테이너는 XML을 기반으로 만들 수 있고, 애노테이션 기반의 자바 설정 클래스로 만들 수 있다.

### BeanFactory와 ApplicationContext
**BeanFactory**
- 스프링 컨테이너의 최상위 인터페이스다.
- 스프링 빈을 관리하고 조회하는 역활을 담당한다.
- getBean()을 제공한다.

**ApplicationContext**
- BeanFactory 기능을 모두 상속받아서 제공한다.
- 빈을 관리하고 검색하는 기능을 BeanFactory가 제공하는데, 둘의 차이는?
- MessageSource, EnvironmentCapable, ApplicationEventPublisher, ResourceLoader 등을 상속받음

**정리**
- ApplicationContext는 BeanFactory의 기능을 상속받는다.
- ApplicationContext는 빈 관리기능 + 편리한 부가 기능을 제공한다.
- BeanFactory를 직접 사용할 일은 거의 없다. 부가기능이 포함된 ApplicationContext를 사용한다.
- BeanFactory나 ApplicationContext를 스프링 컨테이너라고 한다.

### 스프링 빈 설정 메타 정보 - BeanDefinition
- 스프링은 어떻게 이런 다양한 설정 형식을 지원하는 것일까? 그 중심에는 'BeanDefinition'이라는 추상화가 있다.
- 쉽게 이야기해서 역활과 구현을 개념적으로 나눈 것 이다.
    - xml을 읽어서 BeanDefinition을 만들면 된다.
    - 자바 코드를 읽어서 BeanDefinition을 만들면 된다.
    - 스프링 컨테이너는 자바 코드인지, XML인지 몰라도 된다. 오직 BeanDefinition만 알면 된다.
- BeanDefinition을 빈 설정 메타 정보라 한다.
- 스프링 컨테이너는 이 메타정보를 기반으로 스프링 빈을 생성한다.

**BeanDefinition 정보**
- BeanClassName : 생성할 빈의 클래스 명
- factoryBeanName : 팩토리 역활의 빈을 사용할 경우 이름, 예) appConfig
- factoryMethodName : 빈을 생성할 팩토리 메서드 지정, 예) memberService
- Scope : 싱글톤(기본값)
- lazyInit : 스프링 컨테이너를 생성할 때 빈을 생성하는 것이 아니라, 실제 빈을 사용할 때 까지 최대한 생성을 지연처리 하는지 여부
- InitMethodName : 빈을 생성하고, 의존관계를 적용한 뒤에 호출되는 초기화 메서드 명
- DestoryMethodName : 빈의 생성주기가 끝나서 제거하기 직전에 호출되는 메서드 명
- Constructor arguments, Properties : 의존관계 주입에서 사용한다.

**정리**
- BeanDefinition을 직접 정의해서 스프링 컨테이너에 등록할 수 있다.
- 스프링이 다양한 형태의 설정 정보를 BeanDefinition으로 추상화해서 사용하는 것 정도만 이해하면 된다.

### 싱글톤 패턴
- 클래스의 인스턴스가 딱 1개만 생성되는 것을 보장하는 디자인 패턴이다.
- 그래서 객체 인스턴스를 2개 이상 생성하지 못하도록 막아야 한다.
  - private 생성자를 사용해서 외부에서 임의로 new 키워드를 사용하지 못하도록 막아야 한다.
- static 영역에 객체 instance를 미리 하나 생성해서 올려둔다.
- 이 객체 인스턴스가 필요하면 오직 getInstance() 메서드를 통해서만 조회할 수 있다. 이 메서드를 호출하면 항상 같은 인스턴스를 반환한다.
- 딱 1개의 객체 인스턴스만 존재해야 하므로, 생성자를 private으로 막아서 외부에서 new 키워드로 객체 인스턴스가 생성되는 것을 막는다.
- **spring**은 자동으로 싱글톤 패턴을 적용한다.

### 싱글톤 컨테이너
- 스프링 컨테이너는 싱글톤 패턴의 문제점을 해결하면서, 객체 인스턴스를 싱글톤으로 관리한다.

### 싱글톤 방식의 주의점
- 싱글톤 패턴은 객체 인스턴스를 하나만 생성해서 싱글톤 방식은 여러 클라이언트가 하나의 객체 인스턴스를 공유하기 때문에 싱글톤 객체는 상태를 유지하게 설계하면 안된다.
- **무상태**로 설계해야 한다!
  - 특정 클라이언트에 의존적인 필드가 있으면 안된다
  - 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다.
  - 가급적 읽기만 가능해야 한다.
  - 필드 대신에 자바에서 공유되지 않는, 지역변수, 파라미터, ThreadLocal 등을 사용해야 한다.
- 스프링 빈의 필드에 공유 값을 설정하면 정말 큰 장애가 발생할 수 있다.

### Configuration과 바이트코드 조작의 마법
- 스프링 컨테이너는 싱글톤 레지스트리다. 따라서 스프링 빈이 싱글톤이 되도록 보장해주어야 한다.
- appconfig을 호출하면 hello.core.AppConfig$$EnhancerBySpringCGLIB$$cf40f968 다음과 같이 나온다.
- 이것은 내가 만든 클래스가 아니라 스프링이 CGLIB라는 바이트코드 조작 라이브러리를 사용해서 AppcConfig 클래스를 상송받은 임의의 다른 클래스를 만들고, 그 다른 클래스를 스프링 빈으로 등록한 것이다.
- 이 임의의 다른 클래스가 바로 싱글톤이 보장되도록 해준다.
- @Bean이 붙은 메서드마다 이미 스프링 빈이 존재하면 존재하는 빈을 반환하고, 스프링 빈이 없으면 생성해서 스프링 빈으로 등록하고 반환하는 코드가 동적으로 만들어진다.
- 덕분에 싱글톤이 보장된다.
**정리**
- @Bean만 사용해도 스프링 빈으로 등록되지만, 싱글톤을 보장하진 않는다.
- 크게 고민할 것 없이 @Configuration을 사용한다.

### 컴포턴트 스캔과 의존관계 자동 주입 시작하기
- @ComponentScan은 @Componet가 붙은 모든 클래스를 스프링 빈으로 등록한다.
- 이때 스프링 빈의 기본 이름은 클래스명을 사용하되 맨 앞글자만 소문자를 사용한다.
  - 빈 이름 기본 전략 : MemberServiceImpl -> memberServiceImpl
  - 빈 이름 직접 지정 : @Component("memberService")
- 생성자에 @Autowired를 지정하면, 스프링 컨테이너가 자동으로 해당 스프링 빈을 찾아서 주입한다.
- 필터
  - excludeFilters : 예외처리 필터
  - includeFilters : 포함처리 필터
- 어노테이션은 상속관계라는 것이 없다. 어노테이션은 자바 언어가 지원하는 기능은 아니고, 스프링이 지원하는 기능이다.
- @Controller : 스프링 MVC 컨트롤러로 인식
- @Repository : 스프링 데이터 접근 계층으로 인식하고, 데이터 계층의 에외를 스프링 예외로 변환해준다.
- @Service : @Service는 특별한 처리를 하지 않는다. 대신 개발자들이 핵심 비즈니스 로직이 여기에 있구나 라는 인식을 준다.

### 중복 등록과 충동
- 자동 빈 등록 vs 자동 빈 등록
  - 컴포넌트 스캔에 의해 자동으로 스프링 빈이 등록되는데, 그 이름이 같은 경우 스프링은 오류를 발생시킨다.
- 수동 빈 등록 vs 자동 빈 등록
  - 수동 빈이 자동 빈보다 우선권을 갖는다(수동 빈이 자동 빈을 오버라이딩 해버린다.)
  - 이런 경우 에러로 인지하기가 힘들어서 최근 스트링 부트에서는 에러를 노출한다.
  
### 의존관계 자동 주입
- 다양한 의존관계 주입 방법
  - 생성자 주입
  - 수정자 주입(setter 주입)
  - 필드 주입
  - 일반 메서드 주입
- 생성자 주입
  - @Autowired
  - 생성자 호출시점에 딱 1번만 호출되는 것이 보장된다.
  - "불변, 필수" 의존관계에 사용
  - 생성자가 한개 일때는 @Autowired를 안해도 자동으로 스프링 빈으로 등록 된다.
- 수정자 주입
  - setter라 불리는 필드의 값을 변경하는 수정자 메서드를 통해서 의존관계를 주입하는 방법이다.
  - "선택,변경" 가능성이 있는 의존관계에 사용 (required = false)
  - 자바빈 프로퍼티 규약의 수정자 메서드 방식을 사용하는 방법이다.
- 필드 주입
  - 필드 자체에 @Autowired를 추가한다.
  - 코드가 간결해진다.
  - 외부에서 변경이 불가능해서 테스트하기 힘들다는 단점이 있다.
  - DI 프레임워크가 없으면 할수가 없다(스프링 컨테이너)
  - 왠만하면 사용하지 말자라는 결론
- 일반 메서드 주입
  - 한번에 여러 필드를 주입 받을 수 있다.
  - 일반적으로 잘 사용하지 않는다.
- 옵션 처리
  - @Autowired(required = false) : 자동 주입할 대상이 없으면 수정자 메서드 자체가 호출 안됨
  - @Nullable : 자동 주입할 대상이 없으면 null이 입력된다.
  - Optional<> : 자동 주입할 대상이 없으면 Optional.empty가 입력된다.
  
### 롬복과 최신 트랜드
- 개발해보면, 대부분이 다 불변이고 생성자에 final 키워드를 사용하게 된다.
- 롬북 라이브러리의 @RequiredArgsConstrutor기능을 사용하면 final이 붙은 필드를 모아서 생성자를 자동으로 만들어 준다.
- 롬북이 자바의 애노테이션 프로세서라는 기능을 이용해서 컴파일 시점에 생성자 코드를 생성해준다.

### 조회 빈이 2개 이상인 경우
- @Autowired는 타입으로 조회한다.
- 조회 대상 빈이 2개 이상일 때 해결 방법
  - @Autowired 필드 명 매칭
    1. 타입 매칭
    2. 타입 매칭의 겨로가가 2개 이상일 때 필드명, 파라미터 명으로 빈 이름 매칭
  - @Quilifier -> @Quilifier 끼리 매칭 -> 빈 이름 매칭
    - 추가 구분자를 붙여주는 방법이다. 주입시 추가적인 방법을 제공하는 것이지 빈 이름을 변경하는 것은 아니다.
    1. @Quilifier 끼리 매칭
    2. 빈 이름 매칭
  - @Primary 사용
    - 우선 순위를 정하는 방법이다.